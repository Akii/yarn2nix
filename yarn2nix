#!/usr/bin/env ruby
require 'json'

module Yarn
  module LockParser
    FIRST_FOUR_LINES = [
      "# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.",
      "# yarn lockfile v1",
      "",
      ""
    ]

    class ParseError < RuntimeError
    end

    def self.parse!(content)
      lines = content.split("\n")
      first_four = lines.shift 4

      if first_four != FIRST_FOUR_LINES
        raise RuntimeError.new("First four lines of the yarn lock file do not match! Only lockfile v1 is supported")
      end

      lines2blocks(lines,0).map do |version_constraints, attributes|
        constraints = version_constraints.split(/, ?/)
        { constraints: constraints.map { |constraint| parse_constraint(constraint) }, attributes: attributes }
      end
    end

    private 

    def self.lines2blocks(lines, indent)
      current_block = {}
      loop do
        line = lines.first

        if line.nil?
          return current_block
        end

        m=/^(?<whitespace> *)(?<rest>([^ ].*?)?)(?<colon>:?)$/.match(line)
        line_indent = m["whitespace"].length
        rest = m["rest"]
        has_colon = m["colon"] == ":"

        if line_indent < indent
          return current_block
        elsif line_indent > indent
          raise ParseError.new("Unexpected indentation")
        else
          if rest == ""
            lines.shift
          elsif has_colon
            lines.shift
            key = rest
            value = lines2blocks(lines, indent +2)
            current_block[key] = value
          else
            lines.shift
            key, value = rest.split(" ",2)
            current_block[key] = parse_value(value)
          end
        end
      end
    end

    def self.parse_value(value)
      if m = /^"(?<str>.*)"$/.match(value)
        return m["str"]
      else
        raise ParseError.new("Unkown value: #{value}")
      end
    end

    CONSTRAINT_REGEX=/^"(?<name>.*)@(?<versions>.*)"$|^(?<name2>.*)@(?<versions2>.*)$/
    def self.parse_constraint(constraint)
      if m = CONSTRAINT_REGEX.match(constraint)
        { name: m["name"] || m["name2"] , versions: m["versions"] ||m["versions2"] }
      else
        raise RuntimeError.new("Could not parse constraint '#{constraint}'")
      end
    end
  end
end

module DependencyGraph
  class Node
    attr_reader :name
    attr_reader :version_constraints
    attr_reader :version
    attr_accessor :dependencies
    attr_reader :data

    def initialize(name, version_constraints, version, dependencies, data)
      @name = name
      @version_constraints = version_constraints
      @version = version
      @dependencies = dependencies
      @data = data
    end

    def matches?(name, constraint)
      return false if @name != name
      self.version_constraints.include?(constraint)
    end

    def nix_name
      "#{@name}-#{@version}"
    end

    def flatten
      children = @dependencies.values.map(&:flatten).flatten.uniq
      if @name.nil?
        children
      else
        [self] + children
      end
    end
  end
  
  def self.build(package, lockfile, env=:all)
    nodes = lockfile.map do |entry|
      Node.new(
        entry[:constraints].first[:name], 
        entry[:constraints].map { |x| x[:versions]},
        entry[:attributes]["version"],
        entry[:attributes]["dependencies"]|| {},
        entry[:attributes]["resolved"])
    end

    root = Node.new(nil, nil, nil, package["dependencies"], nil)
    must_resolve = [root]
    processed = []

    while must_resolve.any?
      resolving = must_resolve.shift
      processed << resolving
      new_deps = resolving.dependencies.map do |name, constraints|
        dep_node = nodes.find { |n| n.matches?(name, constraints) }
        if dep_node.nil?
          raise RuntimeError.new("Could not resolve for #{name} #{constraints}")
        end
        must_resolve.push dep_node
        [name, dep_node]
      end
      resolving.dependencies = Hash[new_deps]

      must_resolve -= processed
    end

    root
  end

  def self.to_dot(root)
    output = ["digraph G {"]
    to_add = [root]
    processed = []
    while to_add.any?
      node = to_add.shift
      processed.push node
      output.push " n#{node.object_id} [label=\"#{node.name}\n#{node.version}\"];"
      node.dependencies.each do |name, subnode|
        output.push "n#{node.object_id} -> n#{subnode.object_id}"
        to_add << subnode
      end
      to_add -= processed
    end

    output.push "}"

    output.join("\n")
  end
end

module NixGenerator
  def self.template(manifest, top_level_deps)
    unindent(<<-END_OF_NIX_TEMPLATE, 6)
      { fetchurl, stdenv, symlinkJoin, name, lib }:
      with lib;
      let
        node-modules-dir = stdenv.mkDerivation {
          name = "node-modules-${name}";
          phases = "linkModules linkBin";

          linkModules = ''
            mkdir $out
            #{
              top_level_deps.map do |name, nix_name| 
                "ln -s ${deps.\"#{nix_name}\"} $out/#{name}"
              end.join("\n    ")
            }
          '';

          linkBin = ''
            mkdir $out/.bin
            for bin in $out/*/bin/*; do
              ln -s $bin $out/.bin/$(basename $bin .js)
            done
          '';
        };
        deps = fix (self: {
        #{manifest}
        });
      in
      { inherit node-modules-dir; }
    END_OF_NIX_TEMPLATE
  end

  def self.generate!(dependency_tree)
    all_nodes = dependency_tree.flatten
    deps = all_nodes.map {|node| build_dep(node) }.join("\n")
    top_level_modules = dependency_tree.dependencies.values.map { |dep| [dep.name, dep.nix_name] }
    template(deps, top_level_modules)
  end

  def self.build_dep(dep)
    unindent(<<-END_OF_NIX_TEMPLATE, 4)
      "#{dep.nix_name}" = stdenv.mkDerivation rec {
        name = "yarn-dep-#{dep.nix_name}-installed";
        src = fetchurl {
          name = "yarn-dep-#{dep.nix_name}";
          url = "#{dep.data}";
          sha1 = "#{dep.data.split("#").last}";
        };

        phases = "vendorDepPhase";

        vendorDepPhase = ''
          tar --warning=no-unknown-keyword -xzf ${src}
          mv ./package $out
          mkdir $out/node_modules
          #{dep.dependencies.map { |name, dep| "ln -s ${self.\"#{dep.nix_name}\"} $out/node_modules/#{dep.name}"}.join("\n    ") }
        '';
      };
    END_OF_NIX_TEMPLATE
  end

  def self.unindent(str, amount)
    str.gsub(/^#{" " * amount}/,"")
  end
end

package  = JSON.load(File.read(ARGV[0]))
lockfile = Yarn::LockParser.parse!(File.read(ARGV[1]))

graph = DependencyGraph.build(package, lockfile)

if ENV["WRITE_DOT_TO"]
  File.write(ENV["WRITE_DOT_TO"], DependencyGraph.to_dot(graph))
end

puts NixGenerator.generate!(graph)
